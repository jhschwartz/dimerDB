import sys
import os
import yaml

configfn = 'config.yaml'  
configfile: configfn


sys.path.append(config['paths']['scripts'])
from simple_write import simple_write
from download_uniparc_fasta import download_fasta
from read_fasta import read_prot_from_fasta
from name_pdb import dimer2pdbs
from check_chains_contact import check_chains_contact

sys.path.append(config['paths']['scripts'])
from name_pdb import name_pdb_file

sys.path.append(config['paths']['labels_loc'])
import labels as label_funcs





out_base_path_homo = config['paths']['intermediates_homodimer_filtering']
#out_base_path_hetero = config['paths']['intermediates_heterodimer_filtering']

homodimers_yaml = config['snake_data_yaml_files']['sub1_all_homodimers_yaml']
#heterodimers_yaml = config['snake_data_yaml_files']['sub1_all_heterodimers_yaml']
uniparc2others_yaml = config['snake_data_yaml_files']['sub1_uniparc2others_yaml']


with open(homodimers_yaml, 'r') as f:
    homodimers_data = yaml.safe_load(f)
    samples_homo = homodimers_data.keys()

#with open(heterodimers_yaml, 'r') as f:
#    heterodimers_data = yaml.safe_load(f)
#    samples_hetero = homodimers_data.keys()

divs_homo = [s[-2:] for s in samples_homo]

#def make_het_div(heterodimer_name):
#    u1, u2 = heterodimer_name.split('-')
#    return f'{ u1[-1] }-{ u2[-1] }'
#divs_hetero = [make_het_div(s) for s in samples_hetero]

with open(uniparc2others_yaml, 'r') as f:
    uniparc2others = yaml.safe_load(f)




# len -> afdb -> contact 
localrules: all

rule all:
    input:
        merged_yamlfile_homo = config['snake_data_yaml_files']['sub2_homo_prefiltered_yaml'],
#        merged_yamlfile_hetero = config['snake_data_yaml_files']['sub2_hetero_prefiltered_yaml'],
        merged_uniparc2af_homo = config['snake_data_yaml_files']['sub2_uniparc2af_yaml_homo']
#        merg            f.write(content)
ed_uniparc2af_hetero = config['snake_data_yaml_files']['sub2_uniparc2af_yaml_hetero']
    output:
        done = config['snake_donefiles']['sub2_all_done']
    run:
        simple_write(output.done, 'success')



#####################################
############## ACTIONS ##############
# VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV #


def merge_yamlfiles(infiles, outfile):
    data = {}
    for yamlfile in infiles:    
        with open(yamlfile, 'r') as f:
            data = {**data, **yaml.safe_load(f)} # merge dicts data and the read dict from yaml
    with open(outfile, 'w') as f:
        yaml.dump(data, f, default_flow_style=None)


def make_uniparc2afinfo(afinfo_files, names, outfile):
    uniparc2af = {}
    for afinfo, uniparc in zip(afinfo_files, names):
        with open(afinfo, 'r') as f:
            info = f.read().strip()
        if info != 'no'
            afname = info
            uniparc2af[uniparc] = afname
    with open(outfile, 'w') as f:
        yaml.dump(uniparc2af, f, default_flow_style=None)


def init_indiv_yamls(data, yamlfiles):
    for uniparc, chain_pairs in data.items():
        yamlfile = [yf for yf in yamlfiles if uniparc in yf]
        if len(yamlfile) != 1:
            raise ValueError(f'should find exactly one matching yaml filename for uniparc {uniparc} but found {len(yamlfile)}')
        yamlfile = yamlfile[0]
        if os.path.exists(yamlfile):
            continue
        unit_data = {
            uniparc: chain_pairs
        }
        with open(yamlfile, 'w') as f:
            yaml.dump(unit_data, f, default_flow_style=None)


def write_yes_if_func(outfile, func, *args):
    if func(*args):
        simple_write(outfile, 'yes')
    



def match_seq_to_afdb(query_fasta, afdb_fasta):
    _, target_seq = next(read_prot_from_fasta(input.fasta))
    for header, seq in read_prot_from_fasta(afdb_fasta):
        if seq == target_seq:
            name = re.findall('>AFDB:(.*?)\s', header)[0]
            return name
    return None


def filter_only_contacting_structures(uniparc, inyaml, outyaml):
    with open(inyaml, 'r') as f:
        data = yaml.safe_load(f)
    dimers = data[uniparc]
    dimers_in_contact = []
    
    lib_path = config['paths']['lib']
    dist_thresh = config['database_settings']['dimer_define_contact_distance_threshold_angstroms']
    count_thresh = config['database_settings']['dimer_define_contact_min_total_contacting_pairs']

    for d in dimers:
        pdb1, pdb2 = dimer2pdbs(d, lib_path)
        if check_chains_contact(pdb1, pdb2, label_funcs, dist_thresh, count_thresh):
            dimers_in_contact.append(d)

    if len(dimers_in_contact) > count_thresh:
        data[uniparc] = dimers_in_contact
        with open(outyaml, 'w') as f:
            yaml.dump(data, f, default_flow_style=None)



##########################################
############## HOMODIMER RULES ###########
# VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV #



rule init_indiv_yamls_homo:
    output:
        yamlfiles = expand(out_base_path_homo+'/{div}/{sample}/initial.yaml', zip, div=divs, sample=samples_homo)
    threads: 1
    resources:
       time = "48:00:00",
       mem_mb = "30000"
    run:
        init_indiv_yamls(data=homodimers_data, yamlfiles=output.yamlfiles)






rule prefilter_by_in_afdb_homo:
    input:
        yamlfile = out_base_path_homo+'/{div}/{sample_homo}/initial.yaml'
    output:
        info = out_base_path_homo+'/{div}/{sample}/ok_afdb.info'
    threads: 1
    resources:
        mem_mb = "8000"
    run:
        simple_write(output.info, 'no')
        afdb_fasta = config['paths']['afdb_fasta']
        af_name = match_seq_to_afdb(input.fasta, afdb_fasta)
        if af_name:
            simple_write(output.info, f'{af_name}')


                    
                    

rule prefilter_by_physical_contact:
    input:
        yamlfile = out_base_path_homo+'/{div}/{sample_homo}/initial.yaml',
        info = out_base_path_homo+'/{div}/{sample_homo}/ok_afdb.info'
    output:
        yamlfile = out_base_path_homo+'/{div}/{sample_homo}/incontact.yaml'
    threads: 1
    resources:
        mem_mb = "8000",
        time = "4:00:00"
    run:
        simple_write(output.yamlfile, '')
        with open(input.info, 'r') as f:
             afdb_ok = f.read().strip() != 'no'
        if afdb_ok:
            filter_only_contacting_structures(uniparc=wildcards.sample_homo, inyaml=input.yamlfile, outyaml=output.yamlfile)




rule filter_by_redundancy:
    input:
        yamlfile = out_base_path_homo+'/{div}/{sample_homo}/incontact.yaml'
    output:
        yamlfile = out_base_path_homo+'/{div}/{sample_homo}/incontact_nonredundant.yaml'
    threads: 4
    resources:
        mem_mb = 5000,
        time = "4:00:00"
    run:
        simple_write(output.yamlfile, '')
        with open(input.yamlfile, 'r') as f:
            loaded = yaml.safe_load()
        if loaded: 
            uniparc = loaded.keys()[0]
            structures = loaded[uniparc] 
            dimers = RedundantDimerStructures(dimer_tuples=structures, threshold=config['database_settings']['dimer_cluster_distance_threshold'], config=config)
            non_redundant_dimers = {}
            non_redundant_dimers[uniparc] = dimers.prune_redundancy(num_workers=threads)
            with open(output.yamlfile, 'w') as f:
                yaml.dump(non_redundant_dimers, f, default_flow_style=None)





rule merge_homo_data:
    input:
        yamlfiles = expand(out_base_path_homo+'/{div}/{sample}/incontact_nonredundant.yaml', zip, div=divs, sample=samples_homo),
        afinfos = expand(out_base_path_homo+'/{div}/{sample}/ok_afdb.info', zip, div=divs, sample=samples_homo)
    output:
        merged_yamlfile = config['snake_data_yaml_files']['sub2_homo_prefiltered_yaml'],
        merged_uniparc2af = config['snake_data_yaml_files']['sub2_uniparc2af_yaml_homo']
    threads: 1
    resources:
        mem_mb = 5000,
        time = '24:00:00'
    run:
        merge_yamlfiles(infiles=input.yamlfiles, outfile=output.merged_yamlfile)
        make_uniparc2afinfo(afinfo_files=input.afinfos, names=samples_homo, outfile=output.merged_uniparc2af)


